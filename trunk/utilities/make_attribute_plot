#!/usr/bin/env python

import argparse
import scipy
import matplotlib as mpl
import math
import random
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
from lib.output_parsers import get_ensembles_from_state

parser = argparse.ArgumentParser(fromfile_prefix_chars='@')

group0 = parser.add_argument_group('Table specification')
group0.add_argument('table', 	default=None,								help='A file containing tab-delimited statistics of the available components')
group0.add_argument('-nCol',	default=0,		metavar='N',	type=int,	help='The column containing the component names')
group0.add_argument('-xCol',	default=1,		metavar='N',	type=int,	help='The column containing the desired component attribute')
group0.add_argument('-yCol',	default=2,		metavar='N',	type=int,	help='The column to use as y-axis data')

group1 = parser.add_argument_group('Plot options')
group1.add_argument('-title',					default='',				help='The title for the output figure')
group1.add_argument('-xLabel',					default='',				help='The label for the x-axis')
group1.add_argument('-yLabel',					default='',				help='The label for the y-axis')
group1.add_argument('-backend',					default='Agg',	metavar='Agg',	help='Specify the graphics backend for MPL (only used w/ the -nogui option)')
group1.add_argument('-plotArgs',	nargs=2,	action='append',	default=[],	metavar='',	help='Specify arguments for matplotlib as ARG VALUE')
group1.add_argument('-plotProp',	nargs=2,	action='append',	default=[],	metavar='',	help='Set properties for the figure as ARG VALUE')
group1.add_argument('-figsize',		nargs=2,	default=[6,6],	type=int,	metavar='N',	help='Set figure size and ratio: X Y')
group1.add_argument('-axes',		nargs=4,	default=None,	type=int,	metavar='N',	help='The scales for the axes: xmin, xmax, ymin, ymax')
group1.add_argument('-pointScale',				default=20,		type=int,	metavar='20',	help='Set scaling of the component plot points')
group1.add_argument('-pointColor',	nargs=4,	default=[0,0,0,0.1], type=float,	metavar='N',	help='Set color (R G B A) of componenent plot points')

group2 = parser.add_argument_group('Component statistic overlay options')
group2.add_argument('-stats',	default=None,	metavar='<STATS>',		help='A MESMER ensemble statistics file')
group2.add_argument('-statWidth',				default=3,		type=int,	metavar='3.0',	help='Change the width of the selected component plot circles')
group2.add_argument('-statColor',	nargs=4,	default=[0.0,0.5,1.0,1.0],	type=float,	metavar='N',	help='Specifies the RGB color shading (0-1) to be used for the ensemble statistics overlay')
group2.add_argument('-statNorm',	action='store_true', default=False,				help='Normalize variable color saturation for component prevalence')
group2.add_argument('-statSame',	action='store_true', default=False,				help='Do not use variable color saturation for component prevalence')
group2.add_argument('-statWeight',				default=-1.0,	type=float,			help='When plotting MESMER statistics, drop components weighted lower than this amount')
group2.add_argument('-statPrevalence',			default=-1.0,	type=float,			help='When plotting MESMER statistics, drop components with prevalences lower than this amount')
group2.add_argument('-statSubsample',			default=100,	type=float,			help='Randomly subsample selected conformers by a percentage.')

group3 = parser.add_argument_group('Ensemble statistics overlay options')
group2.add_argument('-state',			default=None,	metavar='<STATS>',		help='A MESMER ensemble state file')
group3.add_argument('-stateSolutions',	default=4,		type=int,	metavar='N',	help='The number of unique ensemble solutions to show')
group3.add_argument('-stateSize',		default=20,		type=int,	metavar='20',	help='Set scaling of the highlight plot circles')
group3.add_argument('-stateWidth',		default=3,		type=int,	metavar='3.0',	help='Set the width of the highlight plot circles')
group3.add_argument('-stateConnWidth',	default=2,		type=float,	metavar='2.0',	help='Set the width of the lines connecting ensemble components')
group3.add_argument('-stateColors',		nargs='*',	default=[],		metavar='C',	help='A series of matplotlib colors to use for highlighting different ensemble solutions')

group4 = parser.add_argument_group('Synthetic target specification overlay options')
group4.add_argument('-spec',	default=None,	metavar='<SPEC>',		help='A specification file')
group4.add_argument('-specColor',	nargs=4,	default=[1.0,0.5,0.0,1.0],	type=float,	metavar='N',	help='Specifies the RGB color shading (0-1) to be used for the specification overlay')
group4.add_argument('-specWeight',				default=-1.0,	type=float,			help='When plotting target specifications, drop components weighted lower than this amount')
group4.add_argument('-specLog',		action='store_true', default=False,				help='Use log of spec weight for shading')

group5 = parser.add_argument_group('Highlighting overlay options')
group5.add_argument('-highlight',		nargs='*',	default=[],		metavar='NAME',	help='List of component names to highlight')
group5.add_argument('-highlightID',	nargs='*',	default=[],	type=int,	metavar='N',	help='Highlight unique ensemble IDs provided by get_ensemble_stats')
group5.add_argument('-highlightSize',	default=20,		type=int,	metavar='20',	help='Set scaling of the highlight plot circles')
group5.add_argument('-highlightWidth',	default=3,		type=int,	metavar='3.0',	help='Set the width of the highlight plot circles')
group5.add_argument('-highlightColor',	nargs=3,	default=[1.0,0.0,0.0],	type=float,	metavar='N',	help='Set color (R G B) to use for highlighting')

group6 = parser.add_argument_group('Output options')
group6.add_argument('-nogui', 	action='store_true',	default=False,	help='Don\'t display image.')
group6.add_argument('-figure', 					default=None,	help='The file to write the resulting figure to.')

args = parser.parse_args()

if(args.table==None):
	print "ERROR: You must provide a component attribute table"
	exit()

if(len(args.highlightID)>0 and not args.state):
	print "ERROR: To highlight a specific ensemble ID please provide an ensemble state file."
	exit()

# generate master data lists
tmp = scipy.genfromtxt( args.table, usecols=(args.nCol,args.xCol,args.yCol), dtype=str, unpack=True )

n = len(tmp[0])
tbl_names = list(tmp[0])
tbl_xvals = [0.0]*n
tbl_yvals = [0.0]*n
for i in range(len(tmp[0])):
	tbl_xvals[i] = float(tmp[1][i])
	tbl_yvals[i] = float(tmp[2][i])

if( args.spec ):
	tmp = scipy.genfromtxt( args.spec, usecols=(0,1), dtype=str, unpack=True )
	tmp = (list(tmp[0]),list(tmp[1]))

	tbl_weights = [0.0]*n
	for i in range(len(tmp[0])):
		try:
			k = tbl_names.index(tmp[0][i])
		except:
			print "ERROR: Target specification contains a component (%s) that does not exist in the attribute table." % tmp[0][i]
			exit()
		tbl_weights[k] = float(tmp[1][i])

if( args.stats ):
	c_xvals = []
	c_yvals = []
	c_prevl = []
	c_weigh = []

	f = open( args.stats, 'r' )
	line = f.readline()
	while(line):
		line = f.readline().strip()
		if(line == ''):
			break

		arr = line.split()
		try:
			k = tbl_names.index(arr[0])
		except:
			print "ERROR: Ensemble statistics file contains a component (%s) that does not exist in the attribute table." % arr[0]
			exit()
		c_xvals.append( tbl_xvals[k] )
		c_yvals.append( tbl_yvals[k] )
		c_prevl.append( float(arr[1]) )
		c_weigh.append( float(arr[3]) )

# set up the plot figure
if(args.nogui) and (args.figure):
	mpl.use( args.backend )

import matplotlib.pyplot as plot
plot.figure(1, figsize=(args.figsize[0],args.figsize[1]))

def keepKeys( l, k ):
	""" Returns a new list containing only the specified indexes"""
	new = []
	for i in k:
		new.append(l[i])
	return new

if( args.spec ):
	# sort values by weight, so that more heavily-weighted values will be on top
	o = scipy.argsort( tbl_weights )
	w = scipy.take(tbl_weights,o)

	# throw out elements with weights lower than specified
	keys = []
	for i in range(len(w)):
		if(w[i] > args.specWeight):
			keys.append(i)
	w = keepKeys( w, keys )
	x = keepKeys( scipy.take(tbl_xvals,o), keys )
	y = keepKeys( scipy.take(tbl_yvals,o), keys )

	# use log scaling?
	if(args.specLog):
		for i in range(len(w)):
			w[i] = 1/(-1.0 * math.log(w[i]))

	plot.scatter( tbl_xvals, tbl_yvals, facecolor=args.pointColor, edgecolors='none', s=args.pointScale, zorder=1 )
	if(len(w)>0):
		m = max(w)
		c = [None]*len(keys)
		for i in range(len(keys)):
			a = args.specColor[2]
			if(w[i]/m>0.15): # 15% alpha cutoff for clarity
				a = 1.0
			c[i] = (w[i]/m*args.specColor[0],w[i]/m*args.specColor[1],w[i]/m*args.specColor[2],a)
		plot.scatter( x, y, facecolors=c, edgecolors='none', s=args.pointScale, zorder=1 )

else:
	plot.scatter( tbl_xvals, tbl_yvals, facecolor=args.pointColor, edgecolors='none', s=args.pointScale, zorder=1 )

if( args.stats ):
	o = scipy.argsort( c_prevl )
	w = scipy.take(c_weigh,o)
	p = scipy.take(c_prevl,o)

	# throw out elements with weights or prevalences lower than specified
	keys = []
	for i in range(len(w)):
		if(w[i] > args.statWeight) and (p[i] > args.statPrevalence):
			if( random.random()*100 < args.statSubsample ):
				keys.append(i)

	w = keepKeys( w, keys )
	p = keepKeys( p, keys )
	x = keepKeys( scipy.take(c_xvals,o), keys )
	y = keepKeys( scipy.take(c_yvals,o), keys )

	if(len(p)>0):
		m = max(p)
		c = [None]*len(keys)
		s = [None]*len(keys)
		for i in range(len(keys)):
			s[i] = w[i]*30*args.pointScale
			if(args.statSame):
				c[i] = (args.statColor[0],args.statColor[1],args.statColor[2],args.statColor[3])
			elif(args.statNorm):
				c[i] = (p[i]/m*args.statColor[0],p[i]/m*args.statColor[1],p[i]/m*args.statColor[2],args.statColor[3])
			else:
				c[i] = (p[i]/100.0*args.statColor[0],p[i]/100.0*args.statColor[1],p[i]/100.0*args.statColor[2],args.statColor[3])

		plot.scatter( x, y, edgecolors=c, s=s, zorder=2, facecolors='none', linewidth=args.statWidth )

if( args.state ):

	try:
		ensemble_stats = get_ensembles_from_state( args.state, unique=True )
	except Exception as e:
		print "ERROR: Could not load ensemble information from state file. Reason: %s" % (e)
		exit()

	if( len(args.highlightID)>0 ):
		id_list = args.highlightID
	else: # randomly select a number of solutions
		id_list = range(min(args.stateSolutions, len(ensemble_stats) ))
		random.shuffle(ensemble_stats)

	colorCounter = 0
	args.stateColors.extend( ['b','g','r','c','m','y','w' ] )
	for i in id_list:
		x,y,s = [],[],[]

		for (j,name) in enumerate( ensemble_stats[i]['components'] ):
			try:
				index = tbl_names.index(name)
			except ValueError:
				print "ERROR: the component \"%s\" from the ensemble state file doesn't exist in the attribute table." % (name)
				exit()

			x.append( tbl_xvals[index] )
			y.append( tbl_yvals[index] )
			s.append( 30*args.stateSize*ensemble_stats[i]['weights'][j] )

		if( len(args.highlightID)>0 and i in args.highlightID ):
			plot.scatter( x, y, edgecolors=args.stateColors[colorCounter % len(args.stateColors)], s=s, zorder=3, facecolors='none', linewidth=args.stateWidth )
			#plot.plot( x, y, c=args.stateColors[colorCounter % len(args.stateColors)], linewidth=args.stateConnWidth )
		elif( len(args.highlightID)==0 ):
			plot.scatter( x, y, edgecolors=args.stateColors[colorCounter % len(args.stateColors)], s=s, zorder=3, facecolors='none', linewidth=args.stateWidth )
			plot.plot( x, y, c=args.stateColors[colorCounter % len(args.stateColors)], linewidth=args.stateConnWidth )

		colorCounter+=1

if( len(args.highlight) > 0 ):
	x,y,s,c = [],[],[],[]

	for name in args.highlight:
		try:
			index = tbl_names.index(name)
		except ValueError:
			print "ERROR: the component \"%s\" from highlight list doesn't exist in the attribute table." % (name)
			exit()

		x.append( tbl_xvals[index] )
		y.append( tbl_yvals[index] )
		s.append( 20*args.highlightSize )
		c.append( args.highlightColor )

	plot.scatter( x, y, edgecolors=c, s=s, zorder=4, facecolor='none', linewidth=args.highlightWidth )

for (arg,val) in args.plotArgs:
	mpl.rcParams[ arg ] = val

# set plot options
plot.suptitle( args.title )
plot.xlabel( args.xLabel )
plot.ylabel( args.yLabel )
if(args.axes):
	plot.axis( args.axes )

#t = {}
#for (arg,val) in args.plotProp:
#	t[arg] = val
#	plot.setp( *t )

if(args.figure):
	print "Plotting figure \"%s\"" % args.figure
	plot.savefig( args.figure )

if(not args.nogui) or (not args.figure):
	plot.show()