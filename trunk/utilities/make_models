#!/usr/bin/env python

import argparse
import glob
import os
import sys
import scipy

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
from lib.output_parsers import get_ensembles_from_state

parser = argparse.ArgumentParser()

group0 = parser.add_argument_group('PDBs from ensemble file')
group0.add_argument('-state',							default=None,	metavar='ensembles_*.tbl',				help='MESMER ensemble state file')
group0.add_argument('-id',		type=int,				default=0,		metavar='N',							help='Save components from the ensemble IDs provided by get_ensemble_stats')

group1 = parser.add_argument_group('PDBs from statistics file')
group1.add_argument('-stats',							default=None,	metavar='component_statistics_*.tbl',	help='MESMER component statistics file')
group1.add_argument('-pdbs',	nargs='+',				default=[],		metavar='DIR',							help='Directory(s) containing named PDBs')
group1.add_argument('-Pmin',	type=float,				default=5,		metavar='5%',							help='Minimum prevalence for components to be included')
group1.add_argument('-Wmin',	type=float,				default=0.05,	metavar='0.05',							help='Minimum weighting for components to be included')

group2 = parser.add_argument_group('Output options')
group2.add_argument('-out',								required=True,	metavar='*.pdb',						help='Filename to save output PDB under')
group2.add_argument('-wAttr',	action='store_true',	default=False,											help='Write UCSF Chimera attribute files for prevalence and weighting of each component')

args = parser.parse_args()

if( args.stats == None and args.state == None ):
	print "ERROR: Must provide an ensemble state or component statistics file"
	sys.exit(1)

if( len(args.pdbs) < 1):
	print "ERROR: Must specify at least one directory containing PDBs"
	sys.exit(2)

for dir in args.pdbs:
	if( not os.path.isdir(dir) ):
		print "ERROR: -pdb option dir \"%s\" does not exist" % (dir)
		sys.exit(3)

if( os.path.exists(args.out) ):
	print "ERROR: Output pdb \"%s\" already exists" % (args.out)
	sys.exit(4)

pdbs, pdb_prev, pdb_weight = [], [], []

def match_name( name ):
	global args

	path = None
	for d in args.pdbs:
		test = "%s%s%s.pdb" % (d,os.sep,name)
		if( os.access( test, os.R_OK ) ):
			if( path != None ):
				print "ERROR: duplicate named PDB (\"%s\") found in directories \"%s\" and \"%s\"" % (name,d,os.path.dirname(pdb))
				sys.exit(6)
			else:
				path = test

	if(path == None):
		print "ERROR: Could not find pdb \"%s\" in any of the provided directories" % (name)
		sys.exit(7)

	return path

if( args.state ):
	try:
		ensemble_stats = get_ensembles_from_state( args.state, unique=True )
	except Exception as e:
		print "ERROR: Could not load ensemble information from state file. Reason: %s" % (e)
		exit()

	for (i,name) in enumerate( ensemble_stats[args.id]['components'] ):
		pdbs.append( match_name(name) )
		pdb_prev.append( 1.0 )
		pdb_weight.append( ensemble_stats[args.id]['weights'][i] )

elif( args.stats ):
	try:
		f = open( args.stats, 'r' )
		lines = f.readlines()[1:] # drop the header
		f.close()
	except Exception as e:
		print "ERROR: Could not read -input option \"%s\": %s" % (args.stats,e)
		sys.exit(5)

	for l in lines:
		fields = l.strip().split()

		if(len(fields)<4):
			continue

		if( float(fields[1]) < args.Pmin ):
			continue
		if( float(fields[3]) < args.Wmin ):
			continue

		print "\t%s\t%s\t%s" % (fields[0],fields[1],fields[3])

		pdbs.append( match_name(fields[0]) )
		pdb_prev.append( float(fields[1]) )
		pdb_weight.append( float(fields[3]) )

if( len(pdbs) > 0 ):
	f = open( args.out, 'w' )
else:
	f = None
	print "ERROR: Could not open output file \"%s\"" % (args.out)
	sys.exit(8)

for (i,model) in enumerate(pdbs):
	try:
		f.write("MODEL        %d\n%s\nENDMDL\n" % (i+1, open(model, 'r').read().strip()) )
	except Exception as e:
		print "ERROR: Could not append PDB to output: %s" % (e)
		sys.exit(9)

if( f != None ):
	f.close()

def write_model_attributes( path, name, attributes ):
	f = open( path, 'w' )
	f.write("""# generated by make_generation_models
attribute: %s
match mode: 1-to-1
recipient: molecules
""" % name)
	for (i,a) in enumerate(attributes):
		f.write("\t#0.%i\t%.3f\n" % (i+1,a))
	f.close()

if( args.wAttr ):
	try:
		name = "%s_prevalence" % os.path.splitext(os.path.basename(args.out))[0]
		path = "%s_prevalence.attr" % os.path.splitext(args.out)[0]
		write_model_attributes( path, name, pdb_prev )

		name = "%s_weights" % os.path.splitext(os.path.basename(args.out))[0]
		path = "%s_weights.attr" % os.path.splitext(args.out)[0]
		write_model_attributes( path, name, [100*w for w in pdb_weight] )
	except Exception as e:
		print "ERROR: Could not write attribute lists: %s" % (e)